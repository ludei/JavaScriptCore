### Begin File: InspectorAlternateBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorAlternateBackendDispatchers_h
#define InspectorAlternateBackendDispatchers_h

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

#include "InspectorProtocolTypes.h"
#include <JavaScriptCore/InspectorBackendDispatcher.h>

namespace Inspector {

class AlternateInspectorBackendDispatcher {
public:
    void setBackendDispatcher(PassRefPtr<InspectorBackendDispatcher> dispatcher) { m_backendDispatcher = dispatcher; }
    InspectorBackendDispatcher* backendDispatcher() const { return m_backendDispatcher.get(); }
private:
    RefPtr<InspectorBackendDispatcher> m_backendDispatcher;
};


class AlternateInspectorDatabaseBackendDispatcher : public AlternateInspectorBackendDispatcher {
public:
    virtual ~AlternateInspectorDatabaseBackendDispatcher() { }
    virtual void executeSQLSyncOptionalReturnValues(long callId, int in_databaseId, const String& in_query) = 0;
    virtual void executeSQLAsyncOptionalReturnValues(long callId, int in_databaseId, const String& in_query) = 0;
    virtual void executeSQLSync(long callId, int in_databaseId, const String& in_query) = 0;
    virtual void executeSQLAsync(long callId, int in_databaseId, const String& in_query) = 0;
};

} // namespace Inspector

#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

#endif // !defined(InspectorAlternateBackendDispatchers_h)
### End File: InspectorAlternateBackendDispatchers.h

### Begin File: InspectorBackendCommands.js
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

// Database.
InspectorBackend.registerDatabaseDispatcher = InspectorBackend.registerDomainDispatcher.bind(InspectorBackend, "Database");
InspectorBackend.registerEnum("Database.PrimaryColors", {Red: "red", Green: "green", Blue: "blue"});
InspectorBackend.registerCommand("Database.executeSQLSyncOptionalReturnValues", [{"name": "databaseId", "type": "number", "optional": false}, {"name": "query", "type": "string", "optional": false}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "screenColor", "printColor"]);
InspectorBackend.registerCommand("Database.executeSQLAsyncOptionalReturnValues", [{"name": "databaseId", "type": "number", "optional": false}, {"name": "query", "type": "string", "optional": false}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "screenColor", "printColor"]);
InspectorBackend.registerCommand("Database.executeSQLSync", [{"name": "databaseId", "type": "number", "optional": false}, {"name": "query", "type": "string", "optional": false}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "screenColor", "printColor"]);
InspectorBackend.registerCommand("Database.executeSQLAsync", [{"name": "databaseId", "type": "number", "optional": false}, {"name": "query", "type": "string", "optional": false}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "screenColor", "printColor"]);
InspectorBackend.activateDomain("Database");
### End File: InspectorBackendCommands.js

### Begin File: InspectorBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorBackendDispatchers_h
#define InspectorBackendDispatchers_h

#if ENABLE(INSPECTOR)

#include "InspectorProtocolObjects.h"
#include <inspector/InspectorBackendDispatcher.h>
#include <wtf/PassRefPtr.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

typedef String ErrorString;

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
class AlternateInspectorDatabaseBackendDispatcher;
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

class InspectorDatabaseBackendDispatcherHandler {
public:
    // Named after parameter 'screenColor' while generating command/event executeSQLSyncOptionalReturnValues.
    enum class ScreenColor {
        Red = 0,
        Green = 1,
        Blue = 2,
    }; // enum class ScreenColor
    // Named after parameter 'printColor' while generating command/event executeSQLSyncOptionalReturnValues.
    enum class PrintColor {
        Cyan = 3,
        Magenta = 4,
        Yellow = 5,
        Black = 6,
    }; // enum class PrintColor
    virtual void executeSQLSyncOptionalReturnValues(ErrorString&, int in_databaseId, const String& in_query, RefPtr<Inspector::Protocol::Array<String>>& opt_out_columnNames, Inspector::Protocol::OptOutput<String>* opt_out_notes, Inspector::Protocol::OptOutput<double>* opt_out_timestamp, Inspector::Protocol::OptOutput<Inspector::InspectorObject>* opt_out_values, Inspector::Protocol::OptOutput<Inspector::InspectorValue>* opt_out_payload, Inspector::Protocol::OptOutput<int>* opt_out_databaseId, RefPtr<Inspector::Protocol::Database::Error>& opt_out_sqlError, Inspector::Protocol::Database::PrimaryColors* opt_out_screenColor, InspectorDatabaseBackendDispatcherHandler::PrintColor* opt_out_printColor) = 0;
    class ExecuteSQLAsyncOptionalReturnValuesCallback : public Inspector::InspectorBackendDispatcher::CallbackBase {
    public:
        ExecuteSQLAsyncOptionalReturnValuesCallback(PassRefPtr<Inspector::InspectorBackendDispatcher>, int id);
        void sendSuccess(PassRefPtr<Inspector::Protocol::Array<String>> columnNames, Inspector::Protocol::OptOutput<String>* notes, Inspector::Protocol::OptOutput<double>* timestamp, Inspector::Protocol::OptOutput<Inspector::InspectorObject>* values, Inspector::Protocol::OptOutput<Inspector::InspectorValue>* payload, Inspector::Protocol::OptOutput<int>* databaseId, PassRefPtr<Inspector::Protocol::Database::Error> sqlError, Inspector::Protocol::OptOutput<String>* screenColor, Inspector::Protocol::OptOutput<String>* printColor);
    };
    virtual void executeSQLAsyncOptionalReturnValues(ErrorString&, int in_databaseId, const String& in_query, PassRefPtr<ExecuteSQLAsyncOptionalReturnValuesCallback> callback) = 0;
    virtual void executeSQLSync(ErrorString&, int in_databaseId, const String& in_query, RefPtr<Inspector::Protocol::Array<String>>& out_columnNames, String* out_notes, double* out_timestamp, Inspector::InspectorObject* out_values, Inspector::InspectorValue* out_payload, int* out_databaseId, RefPtr<Inspector::Protocol::Database::Error>& out_sqlError, Inspector::Protocol::Database::PrimaryColors* out_screenColor, InspectorDatabaseBackendDispatcherHandler::PrintColor* out_printColor) = 0;
    class ExecuteSQLAsyncCallback : public Inspector::InspectorBackendDispatcher::CallbackBase {
    public:
        ExecuteSQLAsyncCallback(PassRefPtr<Inspector::InspectorBackendDispatcher>, int id);
        void sendSuccess(PassRefPtr<Inspector::Protocol::Array<String>> columnNames, const String& notes, double timestamp, Inspector::InspectorObject values, Inspector::InspectorValue payload, int databaseId, PassRefPtr<Inspector::Protocol::Database::Error> sqlError, const String& screenColor, const String& printColor);
    };
    virtual void executeSQLAsync(ErrorString&, int in_databaseId, const String& in_query, PassRefPtr<ExecuteSQLAsyncCallback> callback) = 0;
protected:
    virtual ~InspectorDatabaseBackendDispatcherHandler();
};

class InspectorDatabaseBackendDispatcher final : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorDatabaseBackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorDatabaseBackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) override;
private:
    void executeSQLSyncOptionalReturnValues(long callId, const Inspector::InspectorObject& message);
    void executeSQLAsyncOptionalReturnValues(long callId, const Inspector::InspectorObject& message);
    void executeSQLSync(long callId, const Inspector::InspectorObject& message);
    void executeSQLAsync(long callId, const Inspector::InspectorObject& message);
private:
    InspectorDatabaseBackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorDatabaseBackendDispatcherHandler*);
    InspectorDatabaseBackendDispatcherHandler* m_agent;
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
public:
    void setAlternateDispatcher(AlternateInspectorDatabaseBackendDispatcher* alternateDispatcher) { m_alternateDispatcher = alternateDispatcher; }
private:
    AlternateInspectorDatabaseBackendDispatcher* m_alternateDispatcher;
#endif
};

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorBackendDispatchers_h)
### End File: InspectorBackendDispatchers.h

### Begin File: InspectorBackendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorBackendDispatchers.h"

#if ENABLE(INSPECTOR)

#include <inspector/InspectorFrontendChannel.h>
#include <inspector/InspectorValues.h>
#include <wtf/text/CString.h>

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
#include "InspectorAlternateBackendDispatchers.h"
#endif

namespace Inspector {

InspectorDatabaseBackendDispatcherHandler::~InspectorDatabaseBackendDispatcherHandler() { }

PassRefPtr<InspectorDatabaseBackendDispatcher> InspectorDatabaseBackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorDatabaseBackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorDatabaseBackendDispatcher(backendDispatcher, agent));
}

InspectorDatabaseBackendDispatcher::InspectorDatabaseBackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorDatabaseBackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Database"), this);
}

void InspectorDatabaseBackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorDatabaseBackendDispatcher> protect(*this);

    if (method == "executeSQLSyncOptionalReturnValues")
        executeSQLSyncOptionalReturnValues(callId, *message.get());
    else if (method == "executeSQLAsyncOptionalReturnValues")
        executeSQLAsyncOptionalReturnValues(callId, *message.get());
    else if (method == "executeSQLSync")
        executeSQLSync(callId, *message.get());
    else if (method == "executeSQLAsync")
        executeSQLAsync(callId, *message.get());
    else
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, makeString('\'', "Database", '.', method, "' was not found"));
}

void InspectorDatabaseBackendDispatcher::executeSQLSyncOptionalReturnValues(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_databaseId = InspectorBackendDispatcher::getInteger(paramsContainerPtr, ASCIILiteral("databaseId"), nullptr, protocolErrorsPtr);
    String in_query = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("query"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Database.executeSQLSyncOptionalReturnValues");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeSQLSyncOptionalReturnValues(callId, in_databaseId, in_query);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<String>> out_columnNames;
    Inspector::Protocol::OptOutput<String> out_notes;
    Inspector::Protocol::OptOutput<double> out_timestamp;
    Inspector::Protocol::OptOutput<Inspector::InspectorObject> out_values;
    Inspector::Protocol::OptOutput<Inspector::InspectorValue> out_payload;
    Inspector::Protocol::OptOutput<Inspector::Protocol::Database::DatabaseId> out_databaseId;
    RefPtr<Inspector::Protocol::Database::Error> out_sqlError;
    Inspector::Protocol::Database::PrimaryColors out_screenColor;
    InspectorDatabaseBackendDispatcherHandler::PrintColor out_printColor;
    m_agent->executeSQLSyncOptionalReturnValues(error, in_databaseId, in_query, out_columnNames, &out_notes, &out_timestamp, out_values, &out_payload, &out_databaseId, out_sqlError, &out_screenColor, &out_printColor);

    if (!error.length()) {
        if (out_columnNames)
            result->setArray(ASCIILiteral("columnNames"), out_columnNames);
        if (out_notes.isAssigned())
            result->setString(ASCIILiteral("notes"), out_notes.getValue());
        if (out_timestamp.isAssigned())
            result->setDouble(ASCIILiteral("timestamp"), out_timestamp.getValue());
        if (out_values.isAssigned())
            result->setObject(ASCIILiteral("values"), out_values.getValue());
        if (out_payload.isAssigned())
            result->setValue(ASCIILiteral("payload"), out_payload.getValue());
        if (out_databaseId.isAssigned())
            result->setInteger(ASCIILiteral("databaseId"), out_databaseId.getValue());
        if (out_sqlError)
            result->setObject(ASCIILiteral("sqlError"), out_sqlError);
        if (out_screenColor.isAssigned())
            result->setString(ASCIILiteral("screenColor"), out_screenColor.getValue());
        if (out_printColor.isAssigned())
            result->setString(ASCIILiteral("printColor"), out_printColor.getValue());
    }
    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

InspectorDatabaseBackendDispatcherHandler::ExecuteSQLAsyncOptionalReturnValuesCallback::ExecuteSQLAsyncOptionalReturnValuesCallback(PassRefPtr<InspectorBackendDispatcher> backendDispatcher, int id) : Inspector::InspectorBackendDispatcher::CallbackBase(backendDispatcher, id) { }

void InspectorDatabaseBackendDispatcherHandler::ExecuteSQLAsyncOptionalReturnValuesCallback::sendSuccess(PassRefPtr<Inspector::Protocol::Array<String>> columnNames, Inspector::Protocol::OptOutput<String>* notes, Inspector::Protocol::OptOutput<double>* timestamp, Inspector::Protocol::OptOutput<Inspector::InspectorObject>* values, Inspector::Protocol::OptOutput<Inspector::InspectorValue>* payload, Inspector::Protocol::OptOutput<int>* databaseId, PassRefPtr<Inspector::Protocol::Database::Error> sqlError, Inspector::Protocol::OptOutput<String>* screenColor, Inspector::Protocol::OptOutput<String>* printColor)
{
    RefPtr<InspectorObject> jsonMessage = InspectorObject::create();
    if (columnNames)
        jsonMessage->setArray(ASCIILiteral("columnNames"), columnNames);
    if (notes.isAssigned())
        jsonMessage->setString(ASCIILiteral("notes"), notes.getValue());
    if (timestamp.isAssigned())
        jsonMessage->setDouble(ASCIILiteral("timestamp"), timestamp.getValue());
    if (values.isAssigned())
        jsonMessage->setObject(ASCIILiteral("values"), values.getValue());
    if (payload.isAssigned())
        jsonMessage->setValue(ASCIILiteral("payload"), payload.getValue());
    if (databaseId.isAssigned())
        jsonMessage->setInteger(ASCIILiteral("databaseId"), databaseId.getValue());
    if (sqlError)
        jsonMessage->setObject(ASCIILiteral("sqlError"), sqlError);
    if (screenColor.isAssigned())
        jsonMessage->setString(ASCIILiteral("screenColor"), screenColor.getValue());
    if (printColor.isAssigned())
        jsonMessage->setString(ASCIILiteral("printColor"), printColor.getValue());
    sendIfActive(jsonMessage, ErrorString());
}

void InspectorDatabaseBackendDispatcher::executeSQLAsyncOptionalReturnValues(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_databaseId = InspectorBackendDispatcher::getInteger(paramsContainerPtr, ASCIILiteral("databaseId"), nullptr, protocolErrorsPtr);
    String in_query = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("query"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Database.executeSQLAsyncOptionalReturnValues");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeSQLAsyncOptionalReturnValues(callId, in_databaseId, in_query);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<InspectorDatabaseBackendDispatcherHandler::ExecuteSQLAsyncOptionalReturnValuesCallback> callback = adoptRef(new InspectorDatabaseBackendDispatcherHandler::ExecuteSQLAsyncOptionalReturnValuesCallback(m_backendDispatcher,callId));
    m_agent->executeSQLAsyncOptionalReturnValues(error, in_databaseId, in_query, callback);

    if (error.length()) {
        callback->disable();
        m_backendDispatcher->reportProtocolError(&callId, Inspector::InspectorBackendDispatcher::ServerError, error);
        return;
    }
}

void InspectorDatabaseBackendDispatcher::executeSQLSync(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_databaseId = InspectorBackendDispatcher::getInteger(paramsContainerPtr, ASCIILiteral("databaseId"), nullptr, protocolErrorsPtr);
    String in_query = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("query"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Database.executeSQLSync");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeSQLSync(callId, in_databaseId, in_query);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<String>> out_columnNames;
    String out_notes;
    double out_timestamp;
    Inspector::InspectorObject out_values;
    Inspector::InspectorValue out_payload;
    Inspector::Protocol::Database::DatabaseId out_databaseId;
    RefPtr<Inspector::Protocol::Database::Error> out_sqlError;
    Inspector::Protocol::Database::PrimaryColors out_screenColor;
    InspectorDatabaseBackendDispatcherHandler::PrintColor out_printColor;
    m_agent->executeSQLSync(error, in_databaseId, in_query, out_columnNames, &out_notes, &out_timestamp, out_values, &out_payload, &out_databaseId, out_sqlError, &out_screenColor, &out_printColor);

    if (!error.length()) {
        result->setArray(ASCIILiteral("columnNames"), out_columnNames);
        result->setString(ASCIILiteral("notes"), out_notes);
        result->setDouble(ASCIILiteral("timestamp"), out_timestamp);
        result->setObject(ASCIILiteral("values"), out_values);
        result->setValue(ASCIILiteral("payload"), out_payload);
        result->setInteger(ASCIILiteral("databaseId"), out_databaseId);
        result->setObject(ASCIILiteral("sqlError"), out_sqlError);
        result->setString(ASCIILiteral("screenColor"), Inspector::Protocol::getEnumConstantValue(out_screenColor));
        result->setString(ASCIILiteral("printColor"), Inspector::Protocol::getEnumConstantValue(out_printColor));
    }
    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

InspectorDatabaseBackendDispatcherHandler::ExecuteSQLAsyncCallback::ExecuteSQLAsyncCallback(PassRefPtr<InspectorBackendDispatcher> backendDispatcher, int id) : Inspector::InspectorBackendDispatcher::CallbackBase(backendDispatcher, id) { }

void InspectorDatabaseBackendDispatcherHandler::ExecuteSQLAsyncCallback::sendSuccess(PassRefPtr<Inspector::Protocol::Array<String>> columnNames, const String& notes, double timestamp, Inspector::InspectorObject values, Inspector::InspectorValue payload, int databaseId, PassRefPtr<Inspector::Protocol::Database::Error> sqlError, const String& screenColor, const String& printColor)
{
    RefPtr<InspectorObject> jsonMessage = InspectorObject::create();
    jsonMessage->setArray(ASCIILiteral("columnNames"), columnNames);
    jsonMessage->setString(ASCIILiteral("notes"), notes);
    jsonMessage->setDouble(ASCIILiteral("timestamp"), timestamp);
    jsonMessage->setObject(ASCIILiteral("values"), values);
    jsonMessage->setValue(ASCIILiteral("payload"), payload);
    jsonMessage->setInteger(ASCIILiteral("databaseId"), databaseId);
    jsonMessage->setObject(ASCIILiteral("sqlError"), sqlError);
    jsonMessage->setString(ASCIILiteral("screenColor"), Inspector::Protocol::getEnumConstantValue(screenColor));
    jsonMessage->setString(ASCIILiteral("printColor"), Inspector::Protocol::getEnumConstantValue(printColor));
    sendIfActive(jsonMessage, ErrorString());
}

void InspectorDatabaseBackendDispatcher::executeSQLAsync(long callId, const InspectorObject& message)
{
    RefPtr<InspectorArray> protocolErrors = InspectorArray::create();
    RefPtr<InspectorObject> paramsContainer = message.getObject(ASCIILiteral("params"));
    InspectorObject* paramsContainerPtr = paramsContainer.get();
    InspectorArray* protocolErrorsPtr = protocolErrors.get();
    int in_databaseId = InspectorBackendDispatcher::getInteger(paramsContainerPtr, ASCIILiteral("databaseId"), nullptr, protocolErrorsPtr);
    String in_query = InspectorBackendDispatcher::getString(paramsContainerPtr, ASCIILiteral("query"), nullptr, protocolErrorsPtr);
    if (protocolErrors->length()) {
        String errorMessage = String::format("Some arguments of method '%s' can't be processed", "Database.executeSQLAsync");
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::InvalidParams, errorMessage, protocolErrors.release());
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeSQLAsync(callId, in_databaseId, in_query);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    RefPtr<InspectorDatabaseBackendDispatcherHandler::ExecuteSQLAsyncCallback> callback = adoptRef(new InspectorDatabaseBackendDispatcherHandler::ExecuteSQLAsyncCallback(m_backendDispatcher,callId));
    m_agent->executeSQLAsync(error, in_databaseId, in_query, callback);

    if (error.length()) {
        callback->disable();
        m_backendDispatcher->reportProtocolError(&callId, Inspector::InspectorBackendDispatcher::ServerError, error);
        return;
    }
}

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

### End File: InspectorBackendDispatchers.cpp

### Begin File: InspectorFrontendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorFrontendDispatchers_h
#define InspectorFrontendDispatchers_h

#if ENABLE(INSPECTOR)

#include "InspectorProtocolObjects.h"
#include <inspector/InspectorFrontendChannel.h>
#include <inspector/InspectorValues.h>
#include <wtf/PassRefPtr.h>
#include <wtf/text/WTFString.h>

namespace Inspector {



} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorFrontendDispatchers_h)
### End File: InspectorFrontendDispatchers.h

### Begin File: InspectorFrontendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorFrontendDispatchers.h"

#if ENABLE(INSPECTOR)

#include <wtf/text/CString.h>

namespace Inspector {

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

### End File: InspectorFrontendDispatchers.cpp

### Begin File: InspectorProtocolObjects.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorProtocolObjects_h
#define InspectorProtocolObjects_h

#if ENABLE(INSPECTOR)

#include <inspector/InspectorProtocolTypes.h>
#include <wtf/Assertions.h>
#include <wtf/PassRefPtr.h>

namespace Inspector {



namespace Protocol {

// Forward declarations.
namespace Database {
class Error;
enum class PrimaryColors;
} // Database
// End of forward declarations.


// Typedefs.
namespace Database {
/* Unique identifier of Database object. */
typedef int DatabaseId;
} // Database
// End of typedefs.

String getEnumConstantValue(int code);

template<typename T> String getEnumConstantValue(T enumValue)
{
    return getEnumConstantValue(static_cast<int>(enumValue));
}

namespace Database {
/*  */
enum class PrimaryColors {
    Red = 0,
    Green = 1,
    Blue = 2,
}; // enum class PrimaryColors
/* Database error. */
class Error : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MessageSet = 1 << 0,
        CodeSet = 1 << 1,
        AllFieldsSet = (MessageSet | CodeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<Inspector::InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(PassRefPtr</*Error*/Inspector::InspectorObject> ptr)
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
            m_result = ptr;
        }
        friend class Error;
    public:

        Builder<STATE | MessageSet>& setMessage(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MessageSet), property_message_already_set);
            m_result->setString(ASCIILiteral("message"), value);
            return castState<MessageSet>();
        }

        Builder<STATE | CodeSet>& setCode(int value)
        {
            COMPILE_ASSERT(!(STATE & CodeSet), property_code_already_set);
            m_result->setInteger(ASCIILiteral("code"), value);
            return castState<CodeSet>();
        }

        operator RefPtr<Error>& ()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Error) == sizeof(Inspector::InspectorObject), cannot_cast);
            return *reinterpret_cast<RefPtr<Error>*>(&m_result);
        }

        PassRefPtr<Error> release()
        {
            return RefPtr<Error>(*this).release();
        }
    };

    /*
     * Synthetic constructor:
     * RefPtr<Error> result = Error::create()
     *     .setMessage(...)
     *     .setCode(...);
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(Inspector::InspectorObject::create());
    }
    typedef Inspector::Protocol::StructItemTraits ItemTraits;
};

} // Database



} // namespace Protocol

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorProtocolObjects_h)
### End File: InspectorProtocolObjects.h

### Begin File: InspectorProtocolObjects.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorProtocolObjects.h"

#if ENABLE(INSPECTOR)

#include <wtf/text/CString.h>

namespace Inspector {

namespace Protocol {

static const char* const enum_constant_values[] = {
    "red",
    "green",
    "blue",
    "cyan",
    "magenta",
    "yellow",
    "black",
};

String getEnumConstantValue(int code) {
    return enum_constant_values[code];
}



} // namespace Protocol

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

### End File: InspectorProtocolObjects.cpp

### Begin File: RWIProtocolBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include <JavaScriptCore/InspectorAlternateBackendDispatchers.h>
#include <wtf/RetainPtr.h>

@protocol RWIProtocolDatabaseDomainHandler;

namespace Inspector {


class ObjCInspectorDatabaseBackendDispatcher final : public AlternateInspectorDatabaseBackendDispatcher {
public:
    ObjCInspectorDatabaseBackendDispatcher(id<RWIProtocolDatabaseDomainHandler> handler) { m_delegate = handler; }
    virtual void executeSQLSyncOptionalReturnValues(long callId, int in_databaseId, const String& in_query) override;
    virtual void executeSQLAsyncOptionalReturnValues(long callId, int in_databaseId, const String& in_query) override;
    virtual void executeSQLSync(long callId, int in_databaseId, const String& in_query) override;
    virtual void executeSQLAsync(long callId, int in_databaseId, const String& in_query) override;
private:
    RetainPtr<id<RWIProtocolDatabaseDomainHandler>> m_delegate;
};

} // namespace Inspector

### End File: RWIProtocolBackendDispatchers.h

### Begin File: RWIProtocolConfiguration.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "config.h"
#import "RWIProtocolConfiguration.h"

#import "RWIProtocolInternal.h"
#import "RWIProtocolBackendDispatchers.h"
#import <JavaScriptCore/AlternateDispatchableAgent.h>
#import <JavaScriptCore/AugmentableInspectorController.h>
#import <JavaScriptCore/InspectorAlternateBackendDispatchers.h>
#import <JavaScriptCore/InspectorBackendDispatchers.h>

using namespace Inspector;

@implementation RWIProtocolConfiguration
{
    AugmentableInspectorController* _controller;
    id<RWIProtocolDatabaseDomainHandler> _databaseHandler;
}

- (instancetype)initWithController:(AugmentableInspectorController*)controller
{
    self = [super init];
    if (!self)
        return nil;
    ASSERT(controller);
    _controller = controller;
    return self;
}

- (void)dealloc
{
    [_databaseHandler release];
    [super dealloc];
}

- (void)setDatabaseHandler:(id<RWIProtocolDatabaseDomainHandler>)handler
{
    if (handler == _databaseHandler)
        return;

    [_databaseHandler release];
    _databaseHandler = [handler retain];

    auto alternateDispatcher = std::make_unique<ObjCInspectorDatabaseBackendDispatcher>(handler);
    auto alternateAgent = std::make_unique<AlternateDispatchableAgent<InspectorDatabaseBackendDispatcher, AlternateInspectorDatabaseBackendDispatcher>>(ASCIILiteral("Database"), WTF::move(alternateDispatcher));
    _controller->agentRegistry().appendExtraAgent(WTF::move(alternateAgent));
}

- (id<RWIProtocolDatabaseDomainHandler>)databaseHandler
{
    return _databaseHandler;
}

@end


### End File: RWIProtocolConfiguration.mm

### Begin File: RWIProtocolConfiguration.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "RWIProtocol.h"

@interface RWIProtocolConfiguration : NSObject
@property (nonatomic, retain, setter=setDatabaseHandler:) id<RWIProtocolDatabaseDomainHandler> databaseHandler;
@end


### End File: RWIProtocolConfiguration.h

### Begin File: RWIProtocolBackendDispatchers.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "config.h"
#import "RWIProtocolBackendDispatchers.h"

#include "RWIProtocolInternal.h"
#include "RWIProtocolEnumConversionHelpers.h"
#include <JavaScriptCore/InspectorFrontendChannel.h>
#include <JavaScriptCore/InspectorValues.h>

namespace Inspector {

void ObjCInspectorDatabaseBackendDispatcher::executeSQLSyncOptionalReturnValues(long callId, int in_databaseId, const String& in_query)
{
    id errorCallback = ^(NSString *error) {
        backendDispatcher()->sendResponse(callId, InspectorObject::create(), error);
    };

    id successCallback = ^(NSArray/*<NSString>*/ **columnNames, NSString **notes, double *timestamp, RWIProtocolJSONObject **values, RWIProtocolJSONObject **payload, int *databaseId, RWIProtocolDatabaseError **sqlError, RWIProtocolDatabasePrimaryColors *screenColor, RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColor *printColor) {
        RefPtr<InspectorObject> resultObject = InspectorObject::create();
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(notes, @"notes");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(values, @"values");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(payload, @"payload");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(sqlError, @"sqlError");
        if (columnNames)
            resultObject->setArray(ASCIILiteral("columnNames"), inspectorStringArray(*columnNames));
        if (notes)
            resultObject->setString(ASCIILiteral("notes"), *notes);
        if (timestamp)
            resultObject->setDouble(ASCIILiteral("timestamp"), *timestamp);
        if (values)
            resultObject->setObject(ASCIILiteral("values"), [*values toInspectorObject]);
        if (payload)
            resultObject->setValue(ASCIILiteral("payload"), [*payload toInspectorObject]);
        if (databaseId)
            resultObject->setInteger(ASCIILiteral("databaseId"), *databaseId);
        if (sqlError)
            resultObject->setObject(ASCIILiteral("sqlError"), [*sqlError toInspectorObject]);
        if (screenColor)
            resultObject->setString(ASCIILiteral("screenColor"), toProtocolString(*screenColor));
        if (printColor)
            resultObject->setString(ASCIILiteral("printColor"), toProtocolString(*printColor));
        backendDispatcher()->sendResponse(callId, resultObject.release(), String());
    };

    int o_in_databaseId = in_databaseId;
    NSString *o_in_query = in_query;

    [m_delegate executeSQLSyncOptionalReturnValuesWithErrorCallback:errorCallback successCallback:successCallback databaseId:o_in_databaseId query:o_in_query];
}

void ObjCInspectorDatabaseBackendDispatcher::executeSQLAsyncOptionalReturnValues(long callId, int in_databaseId, const String& in_query)
{
    id errorCallback = ^(NSString *error) {
        backendDispatcher()->sendResponse(callId, InspectorObject::create(), error);
    };

    id successCallback = ^(NSArray/*<NSString>*/ **columnNames, NSString **notes, double *timestamp, RWIProtocolJSONObject **values, RWIProtocolJSONObject **payload, int *databaseId, RWIProtocolDatabaseError **sqlError, RWIProtocolDatabasePrimaryColors *screenColor, RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColor *printColor) {
        RefPtr<InspectorObject> resultObject = InspectorObject::create();
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(notes, @"notes");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(values, @"values");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(payload, @"payload");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(sqlError, @"sqlError");
        if (columnNames)
            resultObject->setArray(ASCIILiteral("columnNames"), inspectorStringArray(*columnNames));
        if (notes)
            resultObject->setString(ASCIILiteral("notes"), *notes);
        if (timestamp)
            resultObject->setDouble(ASCIILiteral("timestamp"), *timestamp);
        if (values)
            resultObject->setObject(ASCIILiteral("values"), [*values toInspectorObject]);
        if (payload)
            resultObject->setValue(ASCIILiteral("payload"), [*payload toInspectorObject]);
        if (databaseId)
            resultObject->setInteger(ASCIILiteral("databaseId"), *databaseId);
        if (sqlError)
            resultObject->setObject(ASCIILiteral("sqlError"), [*sqlError toInspectorObject]);
        if (screenColor)
            resultObject->setString(ASCIILiteral("screenColor"), toProtocolString(*screenColor));
        if (printColor)
            resultObject->setString(ASCIILiteral("printColor"), toProtocolString(*printColor));
        backendDispatcher()->sendResponse(callId, resultObject.release(), String());
    };

    int o_in_databaseId = in_databaseId;
    NSString *o_in_query = in_query;

    [m_delegate executeSQLAsyncOptionalReturnValuesWithErrorCallback:errorCallback successCallback:successCallback databaseId:o_in_databaseId query:o_in_query];
}

void ObjCInspectorDatabaseBackendDispatcher::executeSQLSync(long callId, int in_databaseId, const String& in_query)
{
    id errorCallback = ^(NSString *error) {
        backendDispatcher()->sendResponse(callId, InspectorObject::create(), error);
    };

    id successCallback = ^(NSArray/*<NSString>*/ *columnNames, NSString *notes, double timestamp, RWIProtocolJSONObject *values, RWIProtocolJSONObject *payload, int databaseId, RWIProtocolDatabaseError *sqlError, RWIProtocolDatabasePrimaryColors screenColor, RWIProtocolDatabaseExecuteSQLSyncPrintColor printColor) {
        RefPtr<InspectorObject> resultObject = InspectorObject::create();
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(notes, @"notes");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(values, @"values");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(payload, @"payload");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(sqlError, @"sqlError");
        resultObject->setArray(ASCIILiteral("columnNames"), inspectorStringArray(columnNames));
        resultObject->setString(ASCIILiteral("notes"), notes);
        resultObject->setDouble(ASCIILiteral("timestamp"), timestamp);
        resultObject->setObject(ASCIILiteral("values"), [values toInspectorObject]);
        resultObject->setValue(ASCIILiteral("payload"), [payload toInspectorObject]);
        resultObject->setInteger(ASCIILiteral("databaseId"), databaseId);
        resultObject->setObject(ASCIILiteral("sqlError"), [sqlError toInspectorObject]);
        resultObject->setString(ASCIILiteral("screenColor"), toProtocolString(screenColor));
        resultObject->setString(ASCIILiteral("printColor"), toProtocolString(printColor));
        backendDispatcher()->sendResponse(callId, resultObject.release(), String());
    };

    int o_in_databaseId = in_databaseId;
    NSString *o_in_query = in_query;

    [m_delegate executeSQLSyncWithErrorCallback:errorCallback successCallback:successCallback databaseId:o_in_databaseId query:o_in_query];
}

void ObjCInspectorDatabaseBackendDispatcher::executeSQLAsync(long callId, int in_databaseId, const String& in_query)
{
    id errorCallback = ^(NSString *error) {
        backendDispatcher()->sendResponse(callId, InspectorObject::create(), error);
    };

    id successCallback = ^(NSArray/*<NSString>*/ *columnNames, NSString *notes, double timestamp, RWIProtocolJSONObject *values, RWIProtocolJSONObject *payload, int databaseId, RWIProtocolDatabaseError *sqlError, RWIProtocolDatabasePrimaryColors screenColor, RWIProtocolDatabaseExecuteSQLAsyncPrintColor printColor) {
        RefPtr<InspectorObject> resultObject = InspectorObject::create();
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(notes, @"notes");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(values, @"values");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(payload, @"payload");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(sqlError, @"sqlError");
        resultObject->setArray(ASCIILiteral("columnNames"), inspectorStringArray(columnNames));
        resultObject->setString(ASCIILiteral("notes"), notes);
        resultObject->setDouble(ASCIILiteral("timestamp"), timestamp);
        resultObject->setObject(ASCIILiteral("values"), [values toInspectorObject]);
        resultObject->setValue(ASCIILiteral("payload"), [payload toInspectorObject]);
        resultObject->setInteger(ASCIILiteral("databaseId"), databaseId);
        resultObject->setObject(ASCIILiteral("sqlError"), [sqlError toInspectorObject]);
        resultObject->setString(ASCIILiteral("screenColor"), toProtocolString(screenColor));
        resultObject->setString(ASCIILiteral("printColor"), toProtocolString(printColor));
        backendDispatcher()->sendResponse(callId, resultObject.release(), String());
    };

    int o_in_databaseId = in_databaseId;
    NSString *o_in_query = in_query;

    [m_delegate executeSQLAsyncWithErrorCallback:errorCallback successCallback:successCallback databaseId:o_in_databaseId query:o_in_query];
}


} // namespace Inspector

### End File: RWIProtocolBackendDispatchers.mm

### Begin File: RWIProtocolEnumConversionHelpers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "RWIProtocolArrayConversionHelpers.h"

namespace Inspector {

template<typename ObjCEnumType>
ObjCEnumType fromProtocolString(String value);


inline String toProtocolString(RWIProtocolDatabasePrimaryColors value)
{
    switch(value) {
    case RWIProtocolDatabasePrimaryColorsRed:
        return ASCIILiteral("red");
    case RWIProtocolDatabasePrimaryColorsGreen:
        return ASCIILiteral("green");
    case RWIProtocolDatabasePrimaryColorsBlue:
        return ASCIILiteral("blue");
    }
}

template<>
inline RWIProtocolDatabasePrimaryColors fromProtocolString(String value)
{
    if (value == "red")
        return RWIProtocolDatabasePrimaryColorsRed;
    if (value == "green")
        return RWIProtocolDatabasePrimaryColorsGreen;
    if (value == "blue")
        return RWIProtocolDatabasePrimaryColorsBlue;
    ASSERT_NOT_REACHED();
    return RWIProtocolDatabasePrimaryColorsRed;
}

inline String toProtocolString(RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColor value)
{
    switch(value) {
    case RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorCyan:
        return ASCIILiteral("cyan");
    case RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorMagenta:
        return ASCIILiteral("magenta");
    case RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorYellow:
        return ASCIILiteral("yellow");
    case RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorBlack:
        return ASCIILiteral("black");
    }
}

template<>
inline RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColor fromProtocolString(String value)
{
    if (value == "cyan")
        return RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorCyan;
    if (value == "magenta")
        return RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorMagenta;
    if (value == "yellow")
        return RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorYellow;
    if (value == "black")
        return RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorBlack;
    ASSERT_NOT_REACHED();
    return RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorCyan;
}

inline String toProtocolString(RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColor value)
{
    switch(value) {
    case RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorCyan:
        return ASCIILiteral("cyan");
    case RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorMagenta:
        return ASCIILiteral("magenta");
    case RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorYellow:
        return ASCIILiteral("yellow");
    case RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorBlack:
        return ASCIILiteral("black");
    }
}

template<>
inline RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColor fromProtocolString(String value)
{
    if (value == "cyan")
        return RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorCyan;
    if (value == "magenta")
        return RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorMagenta;
    if (value == "yellow")
        return RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorYellow;
    if (value == "black")
        return RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorBlack;
    ASSERT_NOT_REACHED();
    return RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorCyan;
}

inline String toProtocolString(RWIProtocolDatabaseExecuteSQLSyncPrintColor value)
{
    switch(value) {
    case RWIProtocolDatabaseExecuteSQLSyncPrintColorCyan:
        return ASCIILiteral("cyan");
    case RWIProtocolDatabaseExecuteSQLSyncPrintColorMagenta:
        return ASCIILiteral("magenta");
    case RWIProtocolDatabaseExecuteSQLSyncPrintColorYellow:
        return ASCIILiteral("yellow");
    case RWIProtocolDatabaseExecuteSQLSyncPrintColorBlack:
        return ASCIILiteral("black");
    }
}

template<>
inline RWIProtocolDatabaseExecuteSQLSyncPrintColor fromProtocolString(String value)
{
    if (value == "cyan")
        return RWIProtocolDatabaseExecuteSQLSyncPrintColorCyan;
    if (value == "magenta")
        return RWIProtocolDatabaseExecuteSQLSyncPrintColorMagenta;
    if (value == "yellow")
        return RWIProtocolDatabaseExecuteSQLSyncPrintColorYellow;
    if (value == "black")
        return RWIProtocolDatabaseExecuteSQLSyncPrintColorBlack;
    ASSERT_NOT_REACHED();
    return RWIProtocolDatabaseExecuteSQLSyncPrintColorCyan;
}

inline String toProtocolString(RWIProtocolDatabaseExecuteSQLAsyncPrintColor value)
{
    switch(value) {
    case RWIProtocolDatabaseExecuteSQLAsyncPrintColorCyan:
        return ASCIILiteral("cyan");
    case RWIProtocolDatabaseExecuteSQLAsyncPrintColorMagenta:
        return ASCIILiteral("magenta");
    case RWIProtocolDatabaseExecuteSQLAsyncPrintColorYellow:
        return ASCIILiteral("yellow");
    case RWIProtocolDatabaseExecuteSQLAsyncPrintColorBlack:
        return ASCIILiteral("black");
    }
}

template<>
inline RWIProtocolDatabaseExecuteSQLAsyncPrintColor fromProtocolString(String value)
{
    if (value == "cyan")
        return RWIProtocolDatabaseExecuteSQLAsyncPrintColorCyan;
    if (value == "magenta")
        return RWIProtocolDatabaseExecuteSQLAsyncPrintColorMagenta;
    if (value == "yellow")
        return RWIProtocolDatabaseExecuteSQLAsyncPrintColorYellow;
    if (value == "black")
        return RWIProtocolDatabaseExecuteSQLAsyncPrintColorBlack;
    ASSERT_NOT_REACHED();
    return RWIProtocolDatabaseExecuteSQLAsyncPrintColorCyan;
}

} // namespace Inspector

### End File: RWIProtocolEnumConversionHelpers.h

### Begin File: RWIProtocolEventDispatchers.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "config.h"
#import "RWIProtocolInternal.h"

#import "RWIProtocolEnumConversionHelpers.h"
#import <JavaScriptCore/InspectorFrontendChannel.h>
#import <JavaScriptCore/InspectorValues.h>

using namespace Inspector;




### End File: RWIProtocolEventDispatchers.mm

### Begin File: RWIProtocol.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import <Foundation/Foundation.h>

#import <WebInspector/RWIProtocolJSONObject.h>


@class RWIProtocolDatabaseError;


typedef NS_ENUM(NSInteger, RWIProtocolDatabasePrimaryColors) {
    RWIProtocolDatabasePrimaryColorsRed,
    RWIProtocolDatabasePrimaryColorsGreen,
    RWIProtocolDatabasePrimaryColorsBlue,
};

typedef NS_ENUM(NSInteger, RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColor) {
    RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorCyan,
    RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorMagenta,
    RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorYellow,
    RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColorBlack,
};

typedef NS_ENUM(NSInteger, RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColor) {
    RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorCyan,
    RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorMagenta,
    RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorYellow,
    RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColorBlack,
};

typedef NS_ENUM(NSInteger, RWIProtocolDatabaseExecuteSQLSyncPrintColor) {
    RWIProtocolDatabaseExecuteSQLSyncPrintColorCyan,
    RWIProtocolDatabaseExecuteSQLSyncPrintColorMagenta,
    RWIProtocolDatabaseExecuteSQLSyncPrintColorYellow,
    RWIProtocolDatabaseExecuteSQLSyncPrintColorBlack,
};

typedef NS_ENUM(NSInteger, RWIProtocolDatabaseExecuteSQLAsyncPrintColor) {
    RWIProtocolDatabaseExecuteSQLAsyncPrintColorCyan,
    RWIProtocolDatabaseExecuteSQLAsyncPrintColorMagenta,
    RWIProtocolDatabaseExecuteSQLAsyncPrintColorYellow,
    RWIProtocolDatabaseExecuteSQLAsyncPrintColorBlack,
};


@interface RWIProtocolDatabaseError : RWIProtocolJSONObject
- (instancetype)initWithMessage:(NSString *)message code:(int)code;
/* required */ @property (nonatomic, copy) NSString *message;
/* required */ @property (nonatomic, assign) int code;
@end

@protocol RWIProtocolDatabaseDomainHandler <NSObject>
@required
- (void)executeSQLSyncOptionalReturnValuesWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ **columnNames, NSString **notes, double *timestamp, RWIProtocolJSONObject **values, RWIProtocolJSONObject **payload, int *databaseId, RWIProtocolDatabaseError **sqlError, RWIProtocolDatabasePrimaryColors *screenColor, RWIProtocolDatabaseExecuteSQLSyncOptionalReturnValuesPrintColor *printColor))successCallback databaseId:(int)databaseId query:(NSString *)query;
- (void)executeSQLAsyncOptionalReturnValuesWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ **columnNames, NSString **notes, double *timestamp, RWIProtocolJSONObject **values, RWIProtocolJSONObject **payload, int *databaseId, RWIProtocolDatabaseError **sqlError, RWIProtocolDatabasePrimaryColors *screenColor, RWIProtocolDatabaseExecuteSQLAsyncOptionalReturnValuesPrintColor *printColor))successCallback databaseId:(int)databaseId query:(NSString *)query;
- (void)executeSQLSyncWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ *columnNames, NSString *notes, double timestamp, RWIProtocolJSONObject *values, RWIProtocolJSONObject *payload, int databaseId, RWIProtocolDatabaseError *sqlError, RWIProtocolDatabasePrimaryColors screenColor, RWIProtocolDatabaseExecuteSQLSyncPrintColor printColor))successCallback databaseId:(int)databaseId query:(NSString *)query;
- (void)executeSQLAsyncWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ *columnNames, NSString *notes, double timestamp, RWIProtocolJSONObject *values, RWIProtocolJSONObject *payload, int databaseId, RWIProtocolDatabaseError *sqlError, RWIProtocolDatabasePrimaryColors screenColor, RWIProtocolDatabaseExecuteSQLAsyncPrintColor printColor))successCallback databaseId:(int)databaseId query:(NSString *)query;
@end




### End File: RWIProtocol.h

### Begin File: RWIProtocolTypes.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "config.h"
#import "RWIProtocolInternal.h"

#import "RWIProtocolEnumConversionHelpers.h"
#import <JavaScriptCore/InspectorValues.h>
#import <wtf/Assertions.h>
#import <wtf/PassRefPtr.h>

using namespace Inspector;


@implementation RWIProtocolDatabaseError

- (instancetype)initWithMessage:(NSString *)message code:(int)code;
{
    self = [super init];
    if (!self)
        return nil;

    THROW_EXCEPTION_FOR_REQUIRED_PROPERTY(message, @"message");

    self.message = message;
    self.code = code;

    return self;
}

- (void)setMessage:(NSString *)message
{
    [super setString:message forKey:@"message"];
}

- (NSString *)message
{
    return [super stringForKey:@"message"];
}

- (void)setCode:(int)code
{
    [super setInteger:code forKey:@"code"];
}

- (int)code
{
    return [super integerForKey:@"code"];
}

@end


### End File: RWIProtocolTypes.mm

### Begin File: RWIProtocolInternal.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-async-attribute.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "RWIProtocol.h"
#import "RWIProtocolJSONObjectInternal.h"
#import <JavaScriptCore/AugmentableInspectorController.h>
#import <JavaScriptCore/InspectorValues.h>




### End File: RWIProtocolInternal.h
